/**
 * Copyright (C) 2018 salesforce.com, inc.
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Copyright (C) 2018 salesforce.com, inc.
 */

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const { assign, create, defineProperties, defineProperty, freeze, getOwnPropertyDescriptor, getOwnPropertyNames, getPrototypeOf, hasOwnProperty, keys, seal, setPrototypeOf, } = Object;
function isUndefined(obj) {
    return obj === undefined;
}
function isTrue$1(obj) {
    return obj === true;
}
function isFalse$1(obj) {
    return obj === false;
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * In IE11, symbols are expensive.
 * Due to the nature of the symbol polyfill. This method abstract the
 * creation of symbols, so we can fallback to string when native symbols
 * are not supported. Note that we can't use typeof since it will fail when transpiling.
 */
const hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
/** version: 1.1.0 */

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const runtimeFlags = create(null);
// This function is not whitelisted for use within components and is meant for
// configuring runtime feature flags during app initialization.
function setFeatureFlag(name, value) {
    const isBoolean = isTrue$1(value) || isFalse$1(value);
    if (!isBoolean) {
        const message = `Invalid ${typeof value} value specified for the "${name}" flag. Runtime feature flags can only be set to a boolean value.`;
        if (process.env.NODE_ENV === 'production') {
            console.error(message);
        }
        else {
            throw new TypeError(message);
        }
    }
    if (!isUndefined(featureFlagLookup[name])) {
        runtimeFlags[name] = value;
    }
    else {
        console.warn(`LWC feature flag "${name}" is undefined. Possible reasons are that 1) it was misspelled or 2) it was removed from the @lwc/features package.`);
    }
}
// This function is added to the LWC API whitelist (for testing purposes) so we
// add a check to make sure it is not invoked in production.
function setFeatureFlagForTest(name, value) {
    if (process.env.NODE_ENV !== 'production') {
        if (isUndefined(featureFlagLookup[name])) {
            throw new Error(`Feature flag "${name}" is undefined. Possible reasons are that 1) it was misspelled or 2) it was removed from the @lwc/features package.`);
        }
        return setFeatureFlag(name, value);
    }
}

const featureFlagLookup = {
    ENABLE_REACTIVE_SETTER: null,
    // Flags to toggle on/off the enforcement of shadow dom semantic in element/node outside lwc boundary when using synthetic shadow.
    ENABLE_ELEMENT_PATCH: null,
    ENABLE_NODE_LIST_PATCH: null,
    ENABLE_HTML_COLLECTIONS_PATCH: null,
    ENABLE_NODE_PATCH: null,
};

exports.default = featureFlagLookup;
exports.runtimeFlags = runtimeFlags;
exports.setFeatureFlag = setFeatureFlag;
exports.setFeatureFlagForTest = setFeatureFlagForTest;
/** version: 1.1.0 */
